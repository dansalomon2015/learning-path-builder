# ESLint Strict Rules Configuration - ULTRA STRICT TypeScript

## Overview

This project uses **ultra-strict ESLint rules** to enforce maximum type safety and code quality. **Every function must have explicit return types, `any` is completely forbidden, and all code must be fully typed.**

## Configuration Files

- **Root**: `.eslintrc.json` - Base configuration for the monorepo
- **Backend**: `packages/backend/.eslintrc.json` - Ultra-strict TypeScript rules for Node.js backend
- **Frontend**: `packages/frontend/.eslintrc.json` - Ultra-strict React + TypeScript rules for frontend

## Ultra-Strict TypeScript Rules

### ‚ùå **NEVER USE `any`**
- `@typescript-eslint/no-explicit-any`: **error** - `any` is completely forbidden
- **Solution**: Use `unknown` or proper types instead

```typescript
// ‚ùå FORBIDDEN
function process(data: any) { }

// ‚úÖ REQUIRED
function process(data: unknown) { }
// or
function process<T>(data: T) { }
```

### ‚úÖ **EVERYTHING MUST BE EXPLICITLY TYPED**

#### Functions Must Have Explicit Return Types
- `@typescript-eslint/explicit-function-return-type`: **error** - ALL functions must have explicit return types
  - **No exceptions**: Even arrow functions, expressions, and IIFEs must have types
  - **No type inference allowed**: TypeScript can't infer your return types

```typescript
// ‚ùå FORBIDDEN
function calculate(a: number, b: number) {
  return a + b;
}

const process = (data: string) => {
  return data.toUpperCase();
};

// ‚úÖ REQUIRED
function calculate(a: number, b: number): number {
  return a + b;
}

const process = (data: string): string => {
  return data.toUpperCase();
};

// ‚úÖ For React components
const Button: React.FC<ButtonProps> = ({ label }: ButtonProps): JSX.Element => {
  return <button>{label}</button>;
};
```

#### Module Boundaries Must Be Typed
- `@typescript-eslint/explicit-module-boundary-types`: **error** - All exported functions must have explicit types

```typescript
// ‚ùå FORBIDDEN
export function getUser(id: string) {
  return fetch(`/api/users/${id}`);
}

// ‚úÖ REQUIRED
export function getUser(id: string): Promise<User> {
  return fetch(`/api/users/${id}`);
}
```

#### Class Properties Must Have Types
- `@typescript-eslint/explicit-property-modifier-type`: **error** - All class properties must have explicit types

```typescript
// ‚ùå FORBIDDEN
class UserService {
  private client;
  public cache = new Map();
}

// ‚úÖ REQUIRED
class UserService {
  private client: HttpClient;
  public cache: Map<string, User> = new Map();
}
```

#### Parameters Must Have Types
- `@typescript-eslint/typedef`: **error** - All parameters, destructuring, and arrow function parameters must be typed

```typescript
// ‚ùå FORBIDDEN
function process([first, second]) {
  return first + second;
}

const handler = (event) => {
  console.log(event.target);
};

// ‚úÖ REQUIRED
function process([first, second]: [number, number]): number {
  return first + second;
}

const handler = (event: React.MouseEvent<HTMLButtonElement>): void => {
  console.log(event.target);
};
```

### üîí **STRICT TYPE SAFETY RULES**

#### No Unsafe Operations
- `@typescript-eslint/no-unsafe-assignment`: **error** - Prohibits assigning values with unsafe types
- `@typescript-eslint/no-unsafe-member-access`: **error** - Prohibits accessing members on unsafe types
- `@typescript-eslint/no-unsafe-call`: **error** - Prohibits calling functions with unsafe types
- `@typescript-eslint/no-unsafe-return`: **error** - Prohibits returning unsafe types
- `@typescript-eslint/no-unsafe-argument`: **error** - Prohibits passing unsafe types as arguments

```typescript
// ‚ùå FORBIDDEN (if function returns unknown)
const data = getData(); // unknown
const value = data.someProperty; // ERROR: unsafe member access

// ‚úÖ REQUIRED
const data = getData() as UserData;
// or better
function getData(): UserData {
  return fetchData();
}
const value = data.someProperty; // Safe!
```

#### Strict Boolean Expressions
- `@typescript-eslint/strict-boolean-expressions`: **error** - Requires explicit boolean checks

```typescript
// ‚ùå FORBIDDEN
if (user) { } // user might be object, string, number, etc.
if (count) { } // count is number, not boolean

// ‚úÖ REQUIRED
if (user !== null && user !== undefined) { }
// or
if (user != null) { } // checks both null and undefined
if (count > 0) { } // explicit comparison
if (Boolean(user)) { } // explicit conversion
```

#### No Non-Null Assertions
- `@typescript-eslint/no-non-null-assertion`: **error** - Prohibits `!` operator

```typescript
// ‚ùå FORBIDDEN
const value = data!.property;

// ‚úÖ REQUIRED
if (data != null) {
  const value = data.property;
}
// or use optional chaining
const value = data?.property ?? defaultValue;
```

### üìã **ADDITIONAL STRICT RULES**

#### Promises Must Be Handled
- `@typescript-eslint/no-floating-promises`: **error** - All promises must be handled

```typescript
// ‚ùå FORBIDDEN
asyncFunction(); // Promise not handled

// ‚úÖ REQUIRED
await asyncFunction();
// or
asyncFunction().catch(handleError);
// or (if intentionally fire-and-forget)
void asyncFunction();
```

#### No Implicit Void
- `@typescript-eslint/no-confusing-void-expression`: **error** - Prevents confusing void expressions

#### Must Return Await
- `@typescript-eslint/return-await`: **error** - Must explicitly `return await` in async functions

```typescript
// ‚ùå FORBIDDEN
async function fetch(): Promise<User> {
  return getUser(); // missing await
}

// ‚úÖ REQUIRED
async function fetch(): Promise<User> {
  return await getUser();
}
```

## Complete Rule Summary

### Type Safety (ALL ERROR)
- ‚úÖ `no-explicit-any`: **error** - Never use `any`
- ‚úÖ `explicit-function-return-type`: **error** - All functions must have return types (NO EXCEPTIONS)
- ‚úÖ `explicit-module-boundary-types`: **error** - All exports must be typed
- ‚úÖ `explicit-property-modifier-type`: **error** - All class properties must be typed
- ‚úÖ `typedef`: **error** - All parameters must be typed
- ‚úÖ `no-unsafe-*`: **error** - All unsafe operations prohibited
- ‚úÖ `strict-boolean-expressions`: **error** - Explicit boolean checks required
- ‚úÖ `no-non-null-assertion`: **error** - No `!` operator

### Code Quality (ALL ERROR)
- ‚úÖ `no-unused-vars`: **error** - No unused variables
- ‚úÖ `prefer-const`: **error** - Always use `const` when possible
- ‚úÖ `no-var`: **error** - No `var` declarations
- ‚úÖ `eqeqeq`: **error** - Always use `===`
- ‚úÖ `curly`: **error** - Always use braces

### Security (ALL ERROR)
- ‚úÖ `no-eval`: **error** - No `eval()`
- ‚úÖ `no-implied-eval`: **error** - No implicit eval
- ‚úÖ `no-console`: **error** - No `console.*` except `warn`/`error`
- ‚úÖ `no-debugger`: **error** - No `debugger` statements

### Complexity Limits
- ‚úÖ `complexity`: **error** - Max 15
- ‚úÖ `max-depth`: **error** - Max 4 levels
- ‚úÖ `max-params`: **error** - Max 5 parameters
- ‚úÖ `max-lines-per-function`: **warn** - Max 100-150 lines

## Common Errors & Solutions

### Error: Missing return type
```typescript
// ‚ùå Error: Missing return type annotation
const handler = (event: Event) => {
  return event.target;
};

// ‚úÖ Fixed
const handler = (event: Event): EventTarget | null => {
  return event.target;
};
```

### Error: Using `any`
```typescript
// ‚ùå Error: Unexpected any
function process(data: any) { }

// ‚úÖ Fixed - Option 1: Use unknown
function process(data: unknown): void {
  if (typeof data === 'string') {
    // Type guard narrows to string
  }
}

// ‚úÖ Fixed - Option 2: Use generics
function process<T>(data: T): T {
  return data;
}

// ‚úÖ Fixed - Option 3: Define proper type
interface ProcessData {
  id: string;
  value: number;
}
function process(data: ProcessData): void { }
```

### Error: Strict boolean expression
```typescript
// ‚ùå Error: Unexpected truthy value in condition
if (user) { }

// ‚úÖ Fixed
if (user != null) { } // checks null and undefined
// or
if (user !== null && user !== undefined) { }
```

### Error: Unsafe member access
```typescript
// ‚ùå Error: Unsafe member access
const data: unknown = getData();
const value = data.property;

// ‚úÖ Fixed - Option 1: Type guard
function isUserData(data: unknown): data is UserData {
  return typeof data === 'object' && data !== null && 'property' in data;
}

const data: unknown = getData();
if (isUserData(data)) {
  const value = data.property; // Safe!
}

// ‚úÖ Fixed - Option 2: Type assertion (use with caution)
const data = getData() as UserData;
const value = data.property;
```

## Integration with CI/CD

The ESLint checks are integrated into the GitHub Actions workflow (`.github/workflows/ci.yml`) and will **fail the build** if any linting errors are found. **No exceptions.**

## Zero Tolerance Policy

These rules are **non-negotiable**:
- ‚ùå No `any` types
- ‚ùå No untyped functions
- ‚ùå No type inference for return types
- ‚ùå No unsafe operations
- ‚ùå No shortcuts

**All code must be fully and explicitly typed.**

## Disabling Rules (EXTREMELY RARE)

Rules should **NEVER** be disabled. If you absolutely must (e.g., third-party library bug), you must:
1. Document the reason
2. Link to the issue/bug
3. Set a TODO to fix it
4. Get approval from team lead

```typescript
// @ts-expect-error - Third-party library has incorrect types (see: https://github.com/lib/lib/issues/123)
// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
// TODO: Remove when library fixes types
const data: any = problematicLibraryFunction();
```

## Benefits

1. **Maximum Type Safety**: Catches ALL type errors at lint time
2. **Self-Documenting Code**: Types serve as inline documentation
3. **Better IDE Support**: Full autocomplete and refactoring support
4. **Easier Refactoring**: Types ensure correctness when changing code
5. **Team Consistency**: Everyone writes code the same way
6. **No Runtime Type Errors**: Type errors caught at compile time

## Migration Guide

If you're migrating existing code to these strict rules:

1. Start with new files - apply strict rules to new code
2. Fix files one by one - migrate old code incrementally
3. Use `// eslint-disable-next-line` temporarily with TODO comments
4. Set up pre-commit hooks to prevent new violations
5. Run `npm run lint:fix` where possible (limited auto-fix)
